
## 1. 运算符优先级(由高到低)

运算符说明 | Python运算符 | 优先级 | 结合性
-- | -- | -- | --
小括号 | () | 19 | 无
索引运算符 | x[i] 或 x[i1: i2 [:i3]] | 18 | 左
属性访问 | x.attribute | 17 | 左
乘方 | ** | 16 | 左
按位取反 | ~ | 15 | 右
符号运算符 | +（正号）、-（负号） | 14 | 右
乘除 | *、/、//、% | 13 | 左
加减 | +、- | 12 | 左
位移 | >>、<< | 11 | 左
按位与 | & | 10 | 右
按位异或 | ^ | 9 | 左
按位或 | | 8 | 左
比较运算符 | ==、!=、>、>=、<、<=  | 7 | 左
is 运算符 | is、is not | 6 | 左
in 运算符 | in、not in | 5 | 左
逻辑非 | not | 4 | 右
逻辑与 | and | 3 | 左
逻辑或 | or | 2 | 左
逗号运算符 | exp1, exp2 | 1 | 左

## 2. 二进制按位运算
### 2-1. 位运算符
计算机里面所有数据都存储为0，1串，所有的运算归根到底都转为二进制数的运算。相信大家都知道二进制数按位运算的规则
![bit-operation](../Image/bit_operation.jpeg)

例子

```python
1010 & 1100 = 1000
1010 | 1100 = 1110
1010 ^ 1100 = 0110
1010 << 2   = 101000
1010 >> 2   = 10
~1010       = 0101
```

单纯的二进制位之间的这些运算相当简单，但对我们实际编程并没有直接帮助，因为编程过程中需要的经常是数字间的运算


### 2-2. 计算机中数字的存储方式

我们都知道计算机中万物皆为0、1，将万物变为0、1的过程叫做编码，这里我们只讨论将数字编码为0、1的过程。

计算机中对数字的表示有三种方式：原码，反码，补码：

- 原码表示法在数值前面增加了一位符号位（即最高位为符号位）：正数该位为0，负数该位为1。比如十进制3如果用8个二进制位来表示就是 00000011， -3就是 10000011。
- 反码表示方法：正数的反码是其本身；负数的反码是在其原码的基础上，符号位不变，其余各个位取反。
- 补码表示方法：正数的补码是其本身；负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。 (即在反码的基础上+1)

原码容易被人脑直接识别并用于计算，但是对于计算机来说并不友好。所以在计算机系统中，数值一律用补码来表示、运算和存储。使用补码，可以将符号位和数值域统一处理，将加法和减法统一处理。此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。详细的解释可以参考原码, 反码, 补码详解（http://www.cnblogs.com/zhangziqiu/archive/2011/03/30/computercode.html）。

### 2-3. 数字的按位运算
计算机中数字存储为补码形式，各个数之间的运算也是对它们的补码做运算，而且得到的结果也是补码，如下图：

数字的按位运算

![bit-operation](../Image/bit_operation_.png)

各种编程语言都提供了对补码的二进制位直接进行运算的方法。以Python为例：
```python
>>> 0b1010 & 0b1100
8   #1000
>>> 0b1010 | 0b1100
14  #1110
>>> 0b1010 ^ 0b1100
6   #0110
>>> 0b1010 << 2
40  #101000
>>> 0b1010 >> 2
2   #10
>>> ~0b1010
-11 #10000000 00000000 00000000 00001011
>>> type(0b1010)
<type 'int'>
```

上面0b开头的0、1串表示整型数字，在32位操作系统中，Python中int类型一般占32个二进制位，以最后一个求反运算为例子，1010的补码为

    00000000 00000000 00000000 00001010

求反操作后为：

    11111111 11111111 11111111 11110101

即为-11(原码为：10000000 00000000 00000000 00001011)的补码。（对一个数的补码求补码即可得到该数的原码）


### 2-4. 另辟蹊径的按位运算

那么按位运算在实际编程中可以扮演哪些角色呢？简单点地，可以用来判断奇、偶数：num & 0x1，或者对一个数变换符号：~num + 1；复杂点的可以用来交换两个数，求绝对值等等。

#### 2-4-1. 不用额外的变量实现两个数字互换。
```python
def swap(num_1, num_2):
    num_1 ^= num_2
    num_2 ^= num_1
    num_1 ^= num_2
    return num_1, num_2
```

证明很简单，我们只需要明白异或运算满足下面规律：

- 0^a = a;
- a^a = 0;
- a^b^c = a^c^b;

巧妙运用异或可以高效解决很多问题，比如 找出数组中只出现了一次的数（除了一个数只出现一次外，其他数都是出现两次），以及它的升级版：数组中只出现1次的两个数字(百度面试题)。

#### 2-4-2. 不用判断语句来实现求绝对值。
```python
def bit_abs(num):
    negative = num >> 31
    return (num ^ negative) - negative
```

这里假设程序运行环境中操作系统为32位，int型整数(不考虑整数溢出)用32位存储，因此可以用 num>>31 取出符号位，后面的部分留给大伙证明。

### 2-5. Leetcode 题目思路

回到文章开始提到的题目中，我们对除数减去被除数的过程稍作改进。假设求m/n，我们不一次次的 m-n，而是找到n的一个倍数，使得m-x*n尽可能小，这样能减少循环减法的次数，进而提高效率。我们知道在按位操作中，n<< k相当于 n * 2^k，因此可以用2^k 来找合适的x。

我们需要这样的一个数字k，它使得n 2^k 2^(k+1)， 然后用m – n*2^k，得到新的m’。再找相应的k’，做减法，如此循环即可。代码放在这里。

## 2. 位运算实现算术运算

### 2-1. 公式
 - 暂无

### 2-2. 加法
以00111001(57), 01101011(107)为例
> 00111001 ^ 01101011 = 01010010(82)  结果的每一位等于对应位相加且不带进位的加法结果

> 00111001 & 01101011 = 00101001(41)  结果的1表示对应位相加为2，0表示对应位相加小于二，刚好是进位标识

> 进位是向高位进位，也就是说如果某位相加等于2, 则往这个位的左边位进位，所以可以将与运算结果左移一位后和异或运算的结果做加法

```python
(57 ^ 107) + ((57 & 107) << 1) = 164(10100100)
```

```python

def add(a: int, b: int) -> int:
    return (a ^ b) + ((a & b) << 1)
```

### 2-3. 减法
减法可以但加法做, 相当于是加上  减数的取反加 1


```python

def sub(minuend: int, subtrahend: int) -> int:
    Inverse_subtrahend = ~ subtrahend + 1
    # 调用上面加法的函数
    return add(minuend, Inverse_subtrahend)
```

